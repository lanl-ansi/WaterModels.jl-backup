var documenterSearchIndex = {"docs":
[{"location":"math-model/#Mathematical-Models-in-WaterModels-1","page":"Mathematical Models","title":"Mathematical Models in WaterModels","text":"","category":"section"},{"location":"math-model/#Notation-for-Sets-1","page":"Mathematical Models","title":"Notation for Sets","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"A water distribution network can be represented by a directed graph mathcalG = (mathcalN mathcalA), where mathcalN is the set of nodes (e.g., junctions and reservoirs) and mathcalA is the set of arcs (e.g., pipes and valves). Herein, the set of pipes in the network is denoted as mathcalP subset mathcalA, the set of reservoirs (or sources) as mathcalS subset mathcalN, and the set of junctions as mathcalJ subset mathcalN. The set of arcs incident on node i in mathcalN, where i is the tail of the arc, is denoted as mathcalA^-(i) = (i j) in mathcalA. The set of arcs incident on node i in mathcalN, where i is the head of the arc, is denoted as mathcalA^+(i) = (j i) in mathcalA. Reservoirs are always considered to be supply (or source) nodes, and junctions are typically considered to be demand nodes (i.e., the demand for flow at the node is positive). For convenience, it is thus implied that mathcalS cap mathcalJ = emptyset. Finally, many network design problems are concerned with selecting from among a set of discrete resistances mathcalR(i j) = r_1 r_2 dots r_n^mathcalR_ij for a given pipe (i j) in mathcalP.","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"In summary, the following sets are commonly used when defining a WaterModels problem formulation:","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Notation WaterModels Translation Description\nmathcalN wm.ref[:nw][n][:node] nodes\nmathcalJ subset mathcalN wm.ref[:nw][n][:junction] junctions\nmathcalS subset mathcalN wm.ref[:nw][n][:reservoir] reservoirs\nmathcalA wm.ref[:nw][n][:arc] arcs\nmathcalP subset mathcalA wm.ref[:nw][n][:pipe] pipes\nmathcalA^-(i) subset mathcalA wm.ref[:nw][n][:arc_to][i] arcs \"to\" node i\nmathcalA^+(i) subset mathcalA wm.ref[:nw][n][:arc_from][i] arcs \"from\" node i\nmathcalR(i j) wm.ref[:nw][n][:resistance][ij] resistances for (i j) in mathcalP","category":"page"},{"location":"math-model/#Physical-Feasibility-1","page":"Mathematical Models","title":"Physical Feasibility","text":"","category":"section"},{"location":"math-model/#Satisfaction-of-Flow-Bounds-1","page":"Mathematical Models","title":"Satisfaction of Flow Bounds","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"For each arc (i j) in mathcalA, a variable q_ij is used to represent the volumetric flow of water across the arc (in textrmm^3textrms). When q_ij is positive, flow on arc (i j) travels from node i to node j. When q_ij is negative, flow travels from node j to node i. The absolute value of flow along the arc can be bounded by physical capacity, engineering judgment, or network analysis. Having tight bounds is crucial for optimization applications. For example, maximum flow speed and the diameter of the pipe can be used to bound q_ij as per","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"    -fracpi4 v_ij^max D_ij^2 leq q_ij leq fracpi4 v_ij^max D_ij^2","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"where D_ij is the diameter of pipe (i j) and v^max_ij is the maximum flow speed along the pipe.","category":"page"},{"location":"math-model/#Satisfaction-of-Head-Bounds-1","page":"Mathematical Models","title":"Satisfaction of Head Bounds","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Each node potential is denoted as h_i, i in mathcalN, and represents the hydraulic head in units of length (textrmm). The hydraulic head assimilates the elevation and pressure heads at each node, while the velocity head can typically be neglected. For each reservoir i in mathcalS, the hydraulic head is assumed to be fixed at a value h_i^textrmsrc, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"    h_i = h_i^textrmsrc  forall i in mathcalS","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"For each junction i in mathcalJ, a minimum hydraulic head underlineh_i, determined a priori, must first be satisfied. In the interest of tightening the optimization formulation, upper bounds on hydraulic heads can also typically be implied from other network data, e.g.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"    underlineh_i leq h_i leq overlineh_i = max_i in mathcalSh_i^textrmsrc","category":"page"},{"location":"math-model/#Conservation-of-Flow-at-Non-supply-Nodes-1","page":"Mathematical Models","title":"Conservation of Flow at Non-supply Nodes","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Flow must be delivered throughout the network to satisfy fixed demand, q_i^textrmdem, at non-supply nodes, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\tsum_(j i) in mathcalA^-(i) q_ji - sum_(i j) in mathcalA^+(i) q_ij = q_i^textrmdem  forall i in mathcalJ","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"where mathcalA^-(i) and mathcalA^+(i) are the sets of incoming and outgoing arcs of node i, respectively.","category":"page"},{"location":"math-model/#Conservation-of-Flow-at-Supply-Nodes-1","page":"Mathematical Models","title":"Conservation of Flow at Supply Nodes","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"The outflow from each reservoir will be nonnegative by definition, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\tsum_(i j) in mathcalA^+(i) q_ij - sum_(j i) in mathcalA^-(i) q_ji geq 0  forall i in mathcalS","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Additionally, an upper bound on the amount of flow delivered by a reservoir may be written","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\t sum_(i j) in mathcalA^+(i) q_ij - sum_(j i) in mathcalA^-(i) q_ji leq sum_k in mathcalJ q^textrmdem_k  forall i in mathcalR","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"i.e., a reservoir will never send more flow than the amount required to serve all demand.","category":"page"},{"location":"math-model/#Head-Loss-Relationships-1","page":"Mathematical Models","title":"Head Loss Relationships","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"In water distribution networks, flow along an arc is induced by the difference in potential (head) between the two nodes that connect that arc. The relationships that link flow and hydraulic head are commonly referred to as the \"head loss equations\" or \"potential-flow constraints,\" and are generally of the form","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\th_i - h_j = Phi_ij(q_ij)","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"where Phi_ij  mathbbR to mathbbR is a strictly increasing function with rotational symmetry about the origin. Embedding the above equation in a mathematical program clearly introduces non-convexity. (That is, the function Phi_ij(q_ij) is non-convex and the relationship must be satisfied with equality.) As such, different formulations primarily aim to effectively deal with these types of non-convex constraints in an optimization setting.","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Explicit forms of the head loss equation include the Darcy-Weisbach equation, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\th_i - h_j = frac8 L_ij lambda_ij q_ij lvert q_ij rvertpi^2 g D_ij^5","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"and the Hazen-Williams equation, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\th_i - h_j = frac1067 L_ij q_ij lvert q_ij rvert^0852kappa_ij^1852 D_ij^487","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"In these equations, L_ij represents the length of pipe (i j) in mathcalA, lambda_ij represents the friction factor, g is the acceleration due to gravity, and kappa_ij is the roughness coefficient, which depends on the material of the pipe. In the Darcy-Weisbach formulation, lambda_ij depends on the Reynolds number (and thus the flow q_ij) in a nonlinear manner. In WaterModels.jl, the Swamee-Jain equation is used, which serves as an explicit approximation of the implicit Colebrook-White equation. The equation computes the friction factor lambda_ij for (i j) in mathcalA as","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\tlambda_ij = frac025leftlog left(fracepsilon_ij  D_ij37 + frac574textrmRe_ij^09right)right^2","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"where epsilon_ij is the pipe's effective roughness and the Reynold's number textrmRe_ij is defined as","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\ttextrmRe_ij = fracD_ij v_ij rhomu","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"where v_ij is the mean flow speed, rho is the density, and mu is the viscosity. Herein, to remove the source of nonlinearity in the Swamee-Jain equation, v_ij is estimated a priori, making the overall resistance term fixed.","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"When all variables in a head loss equation except q_ij are fixed (as in the relations described above), both the Darcy-Weisbach and Hazen-Williams formulations for head loss reduce to a convenient form, namely","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\th_i - h_j = L_ij r_ij q_ij lvert q_ij rvert^alpha","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Here, r_ij represents the resistance per unit length, and alpha is the exponent required by the head loss relationship (i.e., one for Darcy-Weisbach and 0852 for Hazen-Williams). Thus, the Darcy-Weisbach resistance per unit length is","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\tr_ij = frac8 lambda_ijpi^2 g D_ij^5","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"and the Hazen-Williams resistance per unit length is","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"\tr_ij = frac1067kappa_ij^1852 D_ij^487","category":"page"},{"location":"math-model/#Non-convex-Nonlinear-Program-1","page":"Mathematical Models","title":"Non-convex Nonlinear Program","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"The full non-convex formulation of the physical feasibility problem (NCNLP), which incorporates all requirements from Physical Feasibility, may be written as a system that satisfies the following constraints:","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"beginalign\n    h_i - h_j = L_ij r_ij q_ij lvert q_ij rvert^alpha  forall (i j) in mathcalA labeleqnncnlp-head-loss \n    h_i = h_i^textrmsrc  forall i in mathcalS labeleqnncnlp-head-source \n    sum_(j i) in mathcalA^-(i) q_ji - sum_(i j) in mathcalA^+(i) q_ij = q_i^textrmdem  forall i in mathcalJ labeleqnncnlp-flow-conservation \n    underlineh_i leq h_i leq overlineh_i  forall i in mathcalJ labeleqnncnlp-head-bounds \n    underlineq_ij leq q_ij leq overlineq_ij  forall (i j) in mathcalA labeleqnncnlp-flow-bounds\nendalign","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Here, Constraints eqrefeqnncnlp-head-loss are head loss relationships, Constraints eqrefeqnncnlp-head-source are head bounds at source nodes, Constraints eqrefeqnncnlp-flow-conservation are flow conservation constraints, Constraints eqrefeqnncnlp-head-bounds head bounds at junctions, and Constraints eqrefeqnncnlp-flow-bounds are flow bounds. Note that the sources of non-convexity and nonlinearity are Constraints eqrefeqnncnlp-head-loss.","category":"page"},{"location":"math-model/#Convex-Nonlinear-Program-1","page":"Mathematical Models","title":"Convex Nonlinear Program","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Note that the sources of non-convexity and nonlinearity in the full non-convex formulation of the physical feasibility problem are Constraints eqrefeqnncnlp-head-loss. Because of the symmetry of the head loss relationship, the problem can be modeled instead as a disjunctive program. Here, the disjunction arises from the direction of flow, i.e.,","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation\n   left\n\tbeginalignedc\n\t\t h_i - h_j = L_ij r_ij q_ij^1 + alpha \n              q_ij geq 0\n\tendaligned\n   right\n   lor\n   left\n\tbeginalignedc\n\t\t h_i - h_j = L_ij r_ij (-q_ij)^1 + alpha \n              q_ij  0\n\tendaligned\n   right  forall (i j) in mathcalA labeleqndnlp-head-loss\nendequation","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"which replaces Constraints eqrefeqnncnlp-head-loss in the NCNLP formulation. To model the disjunction, each flow variable q_ij can be decomposed into two nonnegative flow variables, q_ij^+ and q_ij^-, where q_ij = q_ij^+ - q_ij^-. With this in mind, the following convex nonlinear program (CNLP) can be formulated, which is adapted from Section 3 of Global Optimization of Nonlinear Network Design by Raghunathan (2013):","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"beginalign\n     textminimize\n      sum_(i j) in mathcalA fracL_ij r_ij2 + alpha left(q_ij^+)^2 + alpha + (q_ij^-)^2 + alpharight - sum_i in mathcalS h_i^textrmsrc left(sum_(i j) in mathcalA^-(i) (q_ij^+ - q_ij^-) - sum_(j i) in mathcalA^+(i) (q_ji^+ - q_ji^-)right) \n     textsubject to\n      sum_(j i) in mathcalA^-(i) (q_ji^+ - q_ji^-) - sum_(i j) in mathcalA^+(i) (q_ij^+ - q_ij^-) = q_i^textrmdem  forall i in mathcalJ labeleqncnlp-flow-conservation \n       q_ij^+ q_ij^- geq 0  forall (i j) in mathcalA labeleqncnlp-flow-bounds\nendalign","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"renewcommandhat1widehat1","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Suppose that hatmathbfq^+ hatmathbfq^- in mathbbR^lvert A rvert solves (CNLP) with the associated dual solution hatmathbfh in mathbbR^lvert mathcalJ rvert, corresponding to the flow conservation Constraints eqrefeqncnlp-flow-conservation, and hatmathbfu^+ hatmathbfu^- in mathbbR^lvert mathcalA rvert, corresponding to the nonnegativity Constraints eqrefeqncnlp-flow-bounds. This solution must satisfy the first-order necessary conditions","category":"page"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"beginalign\n    hath_i - hath_j = L_ij r_ij hatq_ij lvert q_ij rvert^alpha  forall (i j) in mathcalA \n    h_i = h_i^textrmsrc  forall i in mathcalS \n    sum_(j i) in mathcalA^-(i) q_ji - sum_(i j) in mathcalA^+(i) q_ij = q_i^textrmdem  forall i in mathcalJ \n    underlineh_i leq h_i leq overlineh_i  forall i in mathcalJ \n    underlineq_ij leq q_ij leq overlineq_ij  forall (i j) in mathcalA\nendalign","category":"page"},{"location":"math-model/#Mixed-integer-Convex-Program-1","page":"Mathematical Models","title":"Mixed-integer Convex Program","text":"","category":"section"},{"location":"math-model/#Mixed-integer-Linear-Program-1","page":"Mathematical Models","title":"Mixed-integer Linear Program","text":"","category":"section"},{"location":"math-model/#Optimal-Network-Design-1","page":"Mathematical Models","title":"Optimal Network Design","text":"","category":"section"},{"location":"math-model/#","page":"Mathematical Models","title":"Mathematical Models","text":"Currently, the primary formulation focuses on the problem of optimally designing a water distribution network. More specifically, given a network consisting of reservoirs, junctions, and pipes, the problem aims to select the most cost-effecient resistance from a discrete set of resistances for each pipe to meet demand over the entire network. The set of all possible resistances for a given pipe (i j) in mathcalA is denoted as mathcalR_ij, where each resistance is denoted as r in mathcalR_ij. A binary variable x^r_ijr is associated with each of these diameters to model the decision, i.e., x_ijr^r = 1 if r is selected to serve as the pipe resistance, and x_ijr^r = 0 otherwise. The cost per unit length of installing a pipe of resistance r is denoted as c_ijr.","category":"page"},{"location":"relaxations/#Relaxation-Schemes-1","page":"Relaxation Schemes","title":"Relaxation Schemes","text":"","category":"section"},{"location":"experiment-results/#WaterModels-Experimental-Results-1","page":"Experiment Results","title":"WaterModels Experimental Results","text":"","category":"section"},{"location":"network-data/#WaterModels-Network-Data-Format-1","page":"Network Data Format","title":"WaterModels Network Data Format","text":"","category":"section"},{"location":"developer/#Developer-Documentation-1","page":"Developer","title":"Developer Documentation","text":"","category":"section"},{"location":"parser/#File-I/O-1","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"parser/#","page":"File I/O","title":"File I/O","text":"CurrentModule = WaterModels","category":"page"},{"location":"parser/#General-Data-Formats-1","page":"File I/O","title":"General Data Formats","text":"","category":"section"},{"location":"parser/#","page":"File I/O","title":"File I/O","text":"parse_file\nparse_json","category":"page"},{"location":"parser/#WaterModels.parse_file","page":"File I/O","title":"WaterModels.parse_file","text":"parse_file(path)\n\nParses an EPANET (.inp) or JavaScript Object Notation (JSON) file from the file path path, depending on the file extension, and returns a WaterModels data structure (a dictionary of data).\n\n\n\n\n\n","category":"function"},{"location":"parser/#WaterModels.parse_json","page":"File I/O","title":"WaterModels.parse_json","text":"parse_json(path)\n\nParses a JavaScript Object Notation (JSON) file from the file path path and returns a WaterModels data structure (a dictionary of data).\n\n\n\n\n\n","category":"function"},{"location":"parser/#EPANET-Data-Files-1","page":"File I/O","title":"EPANET Data Files","text":"","category":"section"},{"location":"parser/#","page":"File I/O","title":"File I/O","text":"The following method is the main exported method for parsing EPANET data files:","category":"page"},{"location":"parser/#","page":"File I/O","title":"File I/O","text":"parse_epanet","category":"page"},{"location":"parser/#WaterModels.parse_epanet","page":"File I/O","title":"WaterModels.parse_epanet","text":"parse_epanet(path)\n\nParses an EPANET (.inp) file from the file path path and returns a WaterModels data structure (a dictionary of data). See the OpenWaterAnalytics Wiki for a thorough description of the EPANET format and its components.\n\n\n\n\n\n","category":"function"},{"location":"quickguide/#Quick-Start-Guide-1","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The following guide walks through the solution of a water network design (des) problem using two mixed-integer linear programming formulations (MILP and MILP-R) of the problem specification. This is to enable solution using the readily-available open-source mixed-integer linear programming solver Cbc. Other formulations rely on the availability of mixed-integer nonlinear programming solvers that support user-defined nonlinear functions in JuMP. However, these solvers (e.g., Juniper, KNITRO) either require additional effort to register user-defined functions or are proprietary and require a commercial license.","category":"page"},{"location":"quickguide/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The latest stable release of WaterModels can be installed using the Julia package manager with","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"] add WaterModels","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"For the current development version, install the package using","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"] add WaterModels#master","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Next, test that the package works by executing","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"] test WaterModels","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Install Cbc using","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"] add Cbc","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Finally, install InfrastructureModels using","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"] add InfrastructureModels","category":"page"},{"location":"quickguide/#Solving-a-Network-Expansion-(or-Design)-Problem-1","page":"Getting Started","title":"Solving a Network Expansion (or Design) Problem","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Once the above dependencies have been installed, obtain the files shamir.inp and shamir.json. Here, shamir.inp is an EPANET file describing a simple seven-node, eight-link water distribution network with one reservoir, six junctions, and eight pipes. In accord, shamir.json is a JSON file specifying possible pipe diameters and associated costs per unit length, per diameter setting. The combination of data from these two files provides the required information to set up a corresponding network design problem, where the goal is to select the most cost-efficient pipe diameters while satisfying all demand in the network.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"First, the diameter and cost data from the shamir.json problem specification must be appended to the initial data provided by the EPANET shamir.inp file. To read in the EPANET data, execute the following:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"using WaterModels\ndata = parse_file(\"shamir.inp\")","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Next, to read in the JSON diameter and cost data, execute the following:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"modifications = parse_file(\"shamir.json\")","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"To merge these data together, InfrastructureModels is used to update the original network data using","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"import InfrastructureModels\nInfrastructureModels.update_data!(data, modifications)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Finally, the MILP formulation for the network expansion specification can be solved using","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"import JuMP\nimport Cbc\n\ncbc = JuMP.with_optimizer(Cbc.Optimizer)\nsolve_des(data, MILPWaterModel, cbc)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"By default, only two breakpoints are used for the linear approximation of each head loss curve. These approximations can be more finely discretized by using additional arguments to the solve_des function. For example, to employ five breakpoints per head loss curve in this formulation, the following can be executed:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"solve_des(data, MILPWaterModel, cbc, ext=Dict(:num_breakpoints=>5))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Note that this takes much longer to solve due to the use of more binary variables. However, because of the finer discretization, a lower objective (design cost) can be obtained.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Instead of linear approximation, head loss curves can also be linearly outer-approximated via the MILP-R formulation. This formulation employs less strict requirements and avoids the use of binary variables, but solutions (e.g., diameters) may not necessarily be feasible with respect to the full (nonconvex) water network physics. To employ five outer-approximation points per (positive or negative) head loss curve in this formulation, the following can be executed","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"solve_des(data, MILPRWaterModel, cbc, ext=Dict(:num_breakpoints=>5))","category":"page"},{"location":"quickguide/#Obtaining-Results-1","page":"Getting Started","title":"Obtaining Results","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The run commands in WaterModels return detailed results data in the form of a Julia Dict. This dictionary can be saved for further processing as follows:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"result = solve_des(data, MILPRWaterModel, cbc, ext=Dict(:num_breakpoints=>5))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"For example, the algorithm's runtime and final objective value can be accessed with,","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"result[\"solve_time\"]\nresult[\"objective\"]","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The \"solution\" field contains detailed information about the solution produced by the run method. For example, the following dictionary comprehension can be used to inspect the flows in the solution:","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Dict(name => data[\"q\"] for (name, data) in result[\"solution\"][\"pipe\"])","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Or, to obtain resistances (influenced by the selection of diameters):","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Dict(name => data[\"r\"] for (name, data) in result[\"solution\"][\"pipe\"])","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"For more information about WaterModels result data see the WaterModels Result Data Format section.","category":"page"},{"location":"quickguide/#Accessing-Different-Formulations-1","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The MILP formulations discussed above assume access to a mixed-integer programming (MIP) solver. Mixed-integer nonconvex formulations can be solved with dedicated solvers, as well. For example, the full mixed-integer nonconvex formulation for network expansion (NCNLP) can be solved via","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"import KNITRO\n\nknitro = JuMP.with_optimizer(KNITRO.Optimizer)\nsolve_des(data, NCNLPWaterModel, knitro)","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"and the mixed-integer convex formulation (MICP) can be solved via","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"solve_des(data, MICPWaterModel, knitro)","category":"page"},{"location":"quickguide/#Modifying-Network-Data-1","page":"Getting Started","title":"Modifying Network Data","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates one way to perform multiple WaterModels solves while modifing network data in Julia.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"solve_des(data, MILPRWaterModel, cbc, ext=Dict(:num_breakpoints=>5))\n\ndata[\"junction\"][\"3\"][\"demand\"] *= 2.0\ndata[\"junction\"][\"4\"][\"demand\"] *= 2.0\ndata[\"junction\"][\"5\"][\"demand\"] *= 2.0\n\nsolve_des(data, MILPRWaterModel, cbc, ext=Dict(:num_breakpoints=>5))","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"Note that the greater demands in the second problem result in an overall larger network cost. For additional details about the network data, see the WaterModels Network Data Format section.","category":"page"},{"location":"quickguide/#Alternative-Methods-for-Building-and-Solving-Models-1","page":"Getting Started","title":"Alternative Methods for Building and Solving Models","text":"","category":"section"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates how to break a solve_des call into separate model building and solving steps. This allows inspection of the JuMP model created by WaterModels for the problem.","category":"page"},{"location":"quickguide/#","page":"Getting Started","title":"Getting Started","text":"wm = build_model(data, MILPRWaterModel, WaterModels.post_des)\n\nprint(wm.model)\n\nresult = optimize_model!(wm, cbc)","category":"page"},{"location":"constraints/#Constraints-1","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"CurrentModule = WaterModels","category":"page"},{"location":"constraints/#Constraint-Templates-1","page":"Constraints","title":"Constraint Templates","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"Constraint templates help simplify data wrangling across multiple optimization formulations by providing an abstraction layer between the network data and network constraint definitions. Each constraint template's job is to extract the required parameters from a given network data structure and pass the data as named arguments to the optimization formulation.","category":"page"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"These templates should be defined over AbstractWaterModel and should not refer to model variables. For more details, see the files core/constraint_template.jl and core/constraint.jl. Here, core/constraint_template.jl provides higher-level constraint interfaces by processing network data and calling methods defined in core/constraint.jl.","category":"page"},{"location":"constraints/#Nodal-Constraints-1","page":"Constraints","title":"Nodal Constraints","text":"","category":"section"},{"location":"constraints/#","page":"Constraints","title":"Constraints","text":"constraint_flow_conservation","category":"page"},{"location":"model/#Water-Model-1","page":"WaterModel","title":"Water Model","text":"","category":"section"},{"location":"specifications/#Problem-Specifications-1","page":"Problem Specifications","title":"Problem Specifications","text":"","category":"section"},{"location":"specifications/#Water-Flow-(WF)-1","page":"Problem Specifications","title":"Water Flow (WF)","text":"","category":"section"},{"location":"specifications/#Functions-1","page":"Problem Specifications","title":"Functions","text":"","category":"section"},{"location":"specifications/#","page":"Problem Specifications","title":"Problem Specifications","text":"function_head_loss(wm)","category":"page"},{"location":"specifications/#Objective-1","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications/#","page":"Problem Specifications","title":"Problem Specifications","text":"objective_wf(pm)","category":"page"},{"location":"specifications/#Variables-1","page":"Problem Specifications","title":"Variables","text":"","category":"section"},{"location":"specifications/#","page":"Problem Specifications","title":"Problem Specifications","text":"variable_head(wm, bounded=false)\nvariable_flow(wm, bounded=false)\nvariable_volume(wm, bounded=false)\nvariable_reservoir(wm)\nvariable_tank(wm)","category":"page"},{"location":"specifications/#Constraints-1","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"specifications/#","page":"Problem Specifications","title":"Problem Specifications","text":"for (a, pipe) in ref(wm, :pipe)\n    constraint_head_loss_pipe(wm, a)\nend\n\nfor (a, pump) in ref(wm, :pump)\n    constraint_head_gain_pump(wm, a, force_on=true)\nend\n\nfor (i, node) in ref(wm, :node)\n    constraint_flow_conservation(wm, i)\nend\n\nfor (i, reservoir) in ref(wm, :reservoir)\n    constraint_source_head(wm, i)\n    constraint_source_flow(wm, i)\nend\n\nfor (i, junction) in ref(wm, :junction)\n    if junction[\"demand\"] > 0.0\n        constraint_sink_flow(wm, i)\n    end\nend\n\nfor i in ids(wm, :tank)\n    constraint_link_volume(wm, i)\n    constraint_tank_state(wm, i)\nend","category":"page"},{"location":"result-data/#WaterModels-Result-Data-Format-1","page":"Result Data Format","title":"WaterModels Result Data Format","text":"","category":"section"},{"location":"formulations/#Network-Formulations-1","page":"Network Formulations","title":"Network Formulations","text":"","category":"section"},{"location":"variables/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The following methods provide a compositional approach for defining common variables used in water network optimization models. These methods are always defined over AbstractWaterModel.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Modules = [WaterModels]\nPages   = [\"core/variable.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"variables/#WaterModels.comp_start_value","page":"Variables","title":"WaterModels.comp_start_value","text":"Sets the start value for a given variable.\n\n\n\n\n\n","category":"function"},{"location":"variables/#WaterModels.comp_start_value","page":"Variables","title":"WaterModels.comp_start_value","text":"Sets the start value for a given variable.\n\n\n\n\n\n","category":"function"},{"location":"variables/#WaterModels.sol_component_value-Tuple{AbstractWaterModel,Int64,Symbol,Symbol,Any,Any}","page":"Variables","title":"WaterModels.sol_component_value","text":"Given a variable that is indexed by component IDs, builds the standard solution structure.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_check_valve-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_check_valve","text":"Creates binary variables for all check valves in the network, i.e., x_cv[a] for a in check_valve, where one denotes that the check valve is open.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_fixed_speed_pump_threshold-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_fixed_speed_pump_threshold","text":"Creates binary variables for all pumps in the network, i.e., x_pump[a] for a in pump, where one denotes that the pump is currently on.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_head-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_head","text":"Creates bounded (by default) or unbounded total hydraulic head (or head) variables for all nodes in the network, i.e., h[i] for i in node.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_head_gain-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_head_gain","text":"Creates head gain variables corresponding to all pumps in the network, i.e., g[a] for a in pump. These denote head gains between nodes i and j.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_pump_common-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_pump_common","text":"Creates binary variables for all pumps in the network, i.e., x_pump[a] for a in pump, where one denotes that the pump is currently on.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_reservoir-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_reservoir","text":"Creates outgoing flow variables for all reservoirs in the network, i.e., qr[i] for i in reservoir. Note that these variables are always nonnegative, as there is never incoming flow to a reservoir.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_resistance-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_resistance","text":"Creates binary variables for all network design or design resistances in the network, i.e., x_res[a] for a in pipe, for r in resistance[a], where one denotes that the given resistance is active in the design.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_tank-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_tank","text":"Creates outgoing flow variables for all tanks in the network, i.e., qt[i] for i in tank. Note that, unlike reservoirs, tanks can have inflow.\n\n\n\n\n\n","category":"method"},{"location":"variables/#WaterModels.variable_volume-Tuple{AbstractWaterModel}","page":"Variables","title":"WaterModels.variable_volume","text":"Creates bounded (by default) or unbounded (but still nonnegative) volume variables for all tanks in the network, i.e., V[i] for i in tank.\n\n\n\n\n\n","category":"method"},{"location":"variables/#Link-Variables-1","page":"Variables","title":"Link Variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"variable_flow\nvariable_flow_des","category":"page"},{"location":"variables/#WaterModels.variable_flow","page":"Variables","title":"WaterModels.variable_flow","text":"Create flow variables for CNLP model.\n\n\n\n\n\nCreate flow variables for formulations with binary direction variables.\n\n\n\n\n\nCreates flow variables for NCNLP formulations (q).\n\n\n\n\n\n","category":"function"},{"location":"variables/#WaterModels.variable_flow_des","page":"Variables","title":"WaterModels.variable_flow_des","text":"Create network design flow variables for directed flow formulations.\n\n\n\n\n\nCreate network design flow variables for the CNLP formulation.\n\n\n\n\n\nCreate network design flow variables for undirected flow formulations.\n\n\n\n\n\nCreates network design flow variables for NCNLP formulations (q_des, x_des).\n\n\n\n\n\n","category":"function"},{"location":"objective/#Objective-1","page":"Objective","title":"Objective","text":"","category":"section"},{"location":"objective/#","page":"Objective","title":"Objective","text":"Modules = [WaterModels]\nPages   = [\"core/objective.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"objective/#WaterModels.objective_des-Tuple{AbstractWaterModel}","page":"Objective","title":"WaterModels.objective_des","text":"objective_des(wm::AbstractWaterModel)\n\nSets the objective function for network design (des) problem specifications. By default, the cost of selecting discrete network resistances is minimized.\n\n\n\n\n\n","category":"method"},{"location":"objective/#WaterModels.objective_owf-Tuple{AbstractWaterModel}","page":"Objective","title":"WaterModels.objective_owf","text":"objective_owf(wm::AbstractWaterModel)\n\nSets the objective function for optimal water flow (owf) problem specifications. By default, only feasibility must be satisfied.\n\n\n\n\n\n","category":"method"},{"location":"objective/#WaterModels.objective_wf-Tuple{AbstractWaterModel}","page":"Objective","title":"WaterModels.objective_wf","text":"objective_wf(wm::AbstractWaterModel)\n\nSets the objective function for Water Flow (WF) problem specifications. By default, only feasibility must be satisfied.\n\n\n\n\n\n","category":"method"},{"location":"objective/#Objective-Functions-1","page":"Objective","title":"Objective Functions","text":"","category":"section"},{"location":"objective/#","page":"Objective","title":"Objective","text":"objective_owf","category":"page"},{"location":"objective/#WaterModels.objective_owf","page":"Objective","title":"WaterModels.objective_owf","text":"objective_owf(wm::AbstractWaterModel)\n\nSets the objective function for optimal water flow (owf) problem specifications. By default, only feasibility must be satisfied.\n\n\n\n\n\nDefines the objective for the owf problem is NCNLP formulations.\n\n\n\n\n\n","category":"function"},{"location":"#WaterModels.jl-Documentation-1","page":"Home","title":"WaterModels.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = WaterModels","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"WaterModels.jl is a Julia/JuMP package for steady state water network optimization. It is designed to enable computational evaluation of historical and emerging water network formulations and algorithms using a common platform. The code is engineered to decouple Problem Specifications (e.g., water flow, optimal water flow, network expansion) from Network Formulations (e.g., mixed-integer linear, mixed-integer nonlinear). This decoupling enables the definition of a wide variety of water network optimization formulations and their comparison on common problem specifications.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The latest stable release of WaterModels can be installed using the Julia package manager with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add WaterModels","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For the current development version, install the package using","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add WaterModels#master","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Test that the package works by executing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] test WaterModels","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that the WaterModels tests are comprehensive and can take as long as twenty minutes to complete.","category":"page"},{"location":"#Usage-at-a-Glance-1","page":"Home","title":"Usage at a Glance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"At least one optimization solver is required to run WaterModels. The solver selected typically depends on the type of problem formulation being employed. As an example, to solve a mixed-integer linear programming (MILP) formulation of the water flow feasibility problem, the open-source mixed-integer programming solver CBC can be used. Installation of the JuMP interface to CBC can be performed via the Julia package manner, i.e.,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add Cbc","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then, as one example, an approximation of water flow physics for the well-known shamir network, using ten breakpoints to model each potential (or head) loss curve, can be obtained by executing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Cbc\nusing WaterModels\next = Dict(:num_breakpoints=>10)\nresult = solve_wf(\"shamir.inp\", MILPWaterModel, Cbc.Optimizer, ext=ext)","category":"page"}]
}
